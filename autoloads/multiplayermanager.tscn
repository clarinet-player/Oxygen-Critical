[gd_scene load_steps=2 format=3 uid="uid://bm81c21drbsb4"]

[sub_resource type="GDScript" id="GDScript_w478l"]
script/source = "extends Node


var multiplayer_active := false
var peer = ENetMultiplayerPeer.new()



func _ready():
	
	# Server setup
	if DisplayServer.get_name() == \"headless\":
		
		set_level(1)
		
		multiplayer.peer_connected.connect(_on_connect)
		multiplayer.peer_disconnected.connect(_on_disconnect)
		
		peer.create_server(7777)
		multiplayer.multiplayer_peer = peer
	
	# Client setup
	else:
		
		UiManager.connect(\"request_connect\", connect_player)
		UiManager.connect(\"request_disconnect\", disconnect_player)



#region Connection
# Executed on the client when attempting to connect
func connect_player():
	peer.close()
	peer.create_client(\"66.179.249.44\", 7777)
	multiplayer.multiplayer_peer = peer

func disconnect_player():
	GameManager.clear()
	peer.close()
	multiplayer_active = false
	UiManager.set_active_ui(1)



# Executed on the server when the client connects
func _on_connect(id : int):
	print(\"player connected: \", id)
	
	rpc_id(id, \"connected\")
	rpc_id(id, \"set_level\", 1)
	for player in get_tree().get_nodes_in_group(\"Players\"):
		spawn_object.rpc_id(id, 1, int(str(player.name)), 1, 
			[player.global_position,
			player.global_position,
			Vector3(0, 0, 0),
			player.global_position,
			Vector3(0, 0, 0),
			Vector3(0, 0, 0),
			0])
	
	await get_tree().create_timer(2.0).timeout
	
	var spawnpoint = _find_spawnpoint()
	
	var playerid = GameManager.get_new_id()
	
	var data = [
		spawnpoint.global_position,
		spawnpoint.global_position,
		Vector3(0, 0, 0),
		spawnpoint.global_position,
		Vector3(0, 0, 0),
		spawnpoint.down,
		0 ]
	
	spawn_object(1, playerid, id, data)
	spawn_object.rpc(1, playerid, id, data)

func _on_disconnect(id : int):
	print(\"player disconnected: \", id)
	
	var playerid = GameManager.id_from_auth(id)
	if playerid:
		despawn_object.rpc(playerid)



# Executed on the client when successfully connected to the server
@rpc(\"authority\", \"call_remote\", \"reliable\")
func connected():
	UiManager.set_active_ui(0)
	multiplayer_active = true
#endregion



@rpc(\"authority\", \"call_remote\", \"reliable\")
func spawn_object(type : int, id : int, authority : int, data : Array):
	if type == 1:
		GameManager.spawn_player(id, authority, data)
	elif type == 2:
		GameManager.spawn_bullet(id, authority, data)



@rpc(\"authority\", \"call_local\", \"reliable\")
func despawn_object(id : int):
	GameManager.destroy_object(id)



@rpc(\"authority\", \"call_local\", \"reliable\")
func damage_player(id : int, amount : float):
	var player = GameManager.get_object(id)
	if player:
		player.damage(amount)



@rpc(\"any_peer\", \"call_remote\", \"unreliable\")
func synchronize(id : int, data : Array):
	var node = get_node_or_null(str(id))
	
	if node and \"update\" in node:
		node.update(data)



func _find_spawnpoint() -> Node3D:
	var points = get_tree().get_nodes_in_group(\"Spawnpoints\")
	var players = get_tree().get_nodes_in_group(\"Players\")
	var best_point
	var best_value := 0.0
	
	if points.size() < 1:
		print(\"no spawnpoints!\")
		return null
	
	if players.size() < 1:
		return points.pick_random()
	
	for point in points:
		var value := 0.0
		for player in players:
			value += point.global_position.distance_to(player.global_position)
		if value > best_value:
			best_value = value
			best_point = point
	
	return best_point



@rpc(\"authority\", \"call_remote\", \"reliable\")
func set_level(level : int):
	print(\"set level\")
	if level == 1:
		get_tree().change_scene_to_file(\"res://scenes/playable scene.tscn\")
"

[node name="MultiplayerManager" type="Node"]
script = SubResource("GDScript_w478l")

[gd_scene load_steps=9 format=3 uid="uid://bq3u0xb10re6"]

[ext_resource type="PackedScene" uid="uid://c2hluyirbi4rf" path="res://classes/hitbox.tscn" id="1_2yv3f"]

[sub_resource type="GDScript" id="GDScript_qj47s"]
script/source = "extends RigidBody3D



signal death(id : int)

signal damaged



#region Variables
const walk_acceleration : float = 25.0
const walk_friction : float = 35.0
const walk_max_speed : float = 3.0

const sprint_acceleration : float = 35.0
const sprint_max_speed : float = 5.0
const slide_friction : float = 1.0

const jump_power : float = 2.5

const grapple_range : float = 100.0
const grapple_acceleration : float = 10.0
const grapple_max_speed : float = 7

const timeout_time : int = 1000

var mouse_sensitivity : float

var jump_stamina : float = 1.0

var velocity : Vector3

var _anchored_shape : CollisionShape3D
var _anchor_point_l : Vector3
var _grapple_point : Vector3
var _surface_normal : Vector3

var _reorient := true

enum move_type {
	IDLE,
	WALKING,
	SPRINTING,
	SLIDING
}

var _movement_state : move_type = move_type.IDLE

var health : float = 100
var breach : float = 0

var inventory := Array()
var active_item : Node3D


@export var team := 0


var update_time : int


@onready var camera := $Camera3D
@onready var hitbox := $Hitbox
@onready var audio := $AudioStreamPlayer3D
@onready var hud = UiManager.playerhud
#endregion



func _enter_tree():
	if name != \"Player\":
		set_multiplayer_authority(int(str(name)))



func _ready():
	update_time = Time.get_ticks_msec()
	
	Settings.settings_changed.connect(_load_settings)
	_load_settings()
	
	if is_multiplayer_authority() or !Gamemanager.mp_active:
		$Hitbox/Hitbox.queue_free()
		$Hitbox/MeshInstance3D.queue_free()
		$Hitbox/Hitbox2.queue_free()
		$Hitbox/MeshInstance3D2.queue_free()
	
	elif team == 1:
		var mat = StandardMaterial3D.new()
		mat.albedo_color = Color(0.6, 0, 0)
		$Hitbox/MeshInstance3D.material = mat
		$Hitbox/MeshInstance3D2.material = mat
	
	elif team == 2:
		var mat = StandardMaterial3D.new()
		mat.albedo_color = Color(0, 0, 0.6)
		$Hitbox/MeshInstance3D.material = mat
		$Hitbox/MeshInstance3D2.material = mat
	
	
	if !Gamemanager.mp_active or is_multiplayer_authority():
		
		$Camera3D.current = true
		UiManager.set_ui(3)
		
		Gamemanager.local_player = self
		
		
		var spawnpoint = Gamemanager.find_spawnpoint(self, team)
		
		if spawnpoint:
			global_position = spawnpoint.global_position
			velocity = spawnpoint.down * 10
		
			var _axis = spawnpoint.down.cross(-global_basis.y)
			var _angle = acos(spawnpoint.down.dot(-global_basis.y))
			if !_axis.is_zero_approx():
				rotate(_axis.normalized(), _angle)
			else:
				rotate(global_basis.x, _angle)
			
			_axis = spawnpoint.facing.cross(global_basis.z)
			_angle = acos(spawnpoint.down.dot(global_basis.z))
			if !_axis.is_zero_approx():
				rotate(_axis.normalized(), _angle)
			else:
				rotate(-global_basis.y, _angle)
		
		
		hud.set_health(100)
		hud.set_ammo(false, 0)
		
		
		if !Gamemanager.mp_active or is_multiplayer_authority():
			for item in Settings.saved_inventory:
				if item == 1:
					var ak = preload(\"res://weapons/ak12/ak12.tscn\").instantiate()
					ak.magazine = ak.mag_size
					inventory.append(ak)
				elif item == 2:
					var vector = preload(\"res://weapons/vector/vector.tscn\").instantiate()
					vector.magazine = vector.mag_size
					inventory.append(vector)
				elif item == 3:
					var glock = preload(\"res://weapons/glock/glock.tscn\").instantiate()
					glock.magazine = glock.mag_size
					inventory.append(glock)
				elif item == 4:
					var grenade = preload(\"res://weapons/grenades/he_display.tscn\").instantiate()
					inventory.append(grenade)
				elif item == 5:
					var sealant = preload(\"res://weapons/healing/sealant.tscn\").instantiate()
					inventory.append(sealant)
				elif item == 6:
					var healthkit = preload(\"res://weapons/healing/healthkit.tscn\").instantiate()
					inventory.append(healthkit)



func _load_settings():
	camera.fov = Settings.fov
	mouse_sensitivity = Settings.mouse_sensitivity



func _input(event):
	if Gamemanager.mp_active and !is_multiplayer_authority():
		return
	
	if UiManager.paused:
		return
	
	# Rotating to follow mouse
	if event is InputEventMouseMotion:
		if _anchored_shape and _reorient:
			
			rotate(_surface_normal, event.relative.x * mouse_sensitivity * -0.001)
			rotate(global_transform.basis.x.normalized(), event.relative.y * mouse_sensitivity * -0.001)
			
		else:
			rotate(global_transform.basis.y.normalized(), event.relative.x * mouse_sensitivity * -0.001)
			rotate(global_transform.basis.x.normalized(), event.relative.y * mouse_sensitivity * -0.001)



func _process(delta):
	if Gamemanager.mp_active and !is_multiplayer_authority():
		return
	
	# update anchor gui
	var mode = 0
	if !_anchored_shape:
		mode = 0
	elif velocity.length() > 2:
		mode = 1
	else:
		mode = 2
	
	if _reorient:
		hud.set_hud_anchor(mode, 0)
	elif acos(_surface_normal.dot(global_basis.x)) < PI / 2:
		hud.set_hud_anchor(mode, acos(_surface_normal.dot(global_basis.y)))
	else:
		hud.set_hud_anchor(mode, acos(_surface_normal.dot(-global_basis.y)) + PI)
	
	
	if Input.is_action_just_pressed(\"B\") and !UiManager.paused:
		UiManager.set_ui(4)
	
	if Input.is_action_just_pressed(\"1\") and inventory.size() > 0 and inventory[0] != active_item and !UiManager.paused:
		if active_item:
			camera.remove_child(active_item)
		active_item = inventory[0]
		camera.add_child(active_item)
	
	if Input.is_action_just_pressed(\"2\") and inventory.size() > 1 and inventory[1] != active_item and !UiManager.paused:
		if active_item:
			camera.remove_child(active_item)
		active_item = inventory[1]
		camera.add_child(active_item)
	
	if Input.is_action_just_pressed(\"3\") and inventory.size() > 2 and inventory[2] != active_item and !UiManager.paused:
		if active_item:
			camera.remove_child(active_item)
		active_item = inventory[2]
		camera.add_child(active_item)
	
	if Input.is_action_just_pressed(\"4\")and inventory.size() > 3 and inventory[3] != active_item and !UiManager.paused:
		if active_item:
			camera.remove_child(active_item)
		active_item = inventory[3]
		camera.add_child(active_item)



#region Physics Frame
func _physics_process(delta : float):
	health -= breach * delta
	if Gamemanager.playable_area and !Gamemanager.playable_area.has_point(global_position):
		health -= 100 * delta
	hud.set_health(health)
	
	if Gamemanager.mp_active and !is_multiplayer_authority():
		if Time.get_ticks_msec() - update_time > timeout_time:
			Gamemanager.timeout.rpc_id(int(str(name)))
			print(\"player disconnected: \", name)
			queue_free()
			return
		
		if health <= 0.1:
			die.rpc()
		
		return
	
	
	if !active_item:
		if inventory.size() > 0:
			active_item = inventory[0]
			camera.add_child(active_item)
	
	
	# Regain stamina
	if jump_stamina < 1:
		jump_stamina += delta * 2
		if jump_stamina > 1:
			jump_stamina = 1
	
	
	if _anchored_shape:
		
		# Modifying Movement State
		if Input.is_action_pressed(\"Control\"):
			if _movement_state != move_type.SLIDING:
				_movement_state = move_type.SLIDING
		else:
			_reorient = true
			if _movement_state == move_type.SLIDING:
				_movement_state = move_type.IDLE
			
		if (Input.is_action_pressed(\"W\") or Input.is_action_pressed(\"A\") or Input.is_action_pressed(\"S\") or Input.is_action_pressed(\"D\")) and !UiManager.paused:
			if _movement_state == move_type.IDLE:
				_movement_state = move_type.WALKING
		elif _movement_state != move_type.SLIDING:
			_movement_state = move_type.IDLE
		
		if Input.is_action_pressed(\"Shift\") and _movement_state == move_type.WALKING:
			_movement_state = move_type.SPRINTING
		
		
		# Move to follow our anchor
		var newpos = _anchored_shape.to_global(_anchor_point_l)
		global_position = newpos
		if \"centrifuge_angular_velocity\" in _anchored_shape.get_parent():
			var ang_vel : Vector3 = _anchored_shape.get_parent().centrifuge_angular_velocity
			global_rotate(ang_vel.normalized(), ang_vel.length() * delta)
			_surface_normal = _surface_normal.rotated(ang_vel.normalized(), ang_vel.length() * delta)
		
		# Adjust roll to avoid gimbal lock
		if _reorient:
			var _roll : Vector3 = global_transform.basis.z
			var _up : Vector3 = global_transform.basis.y
			var _adjusted_normal : Vector3 = (_surface_normal - _surface_normal.dot(_roll) * _roll).normalized()
			var _roll_angle : float = acos(_up.dot(_adjusted_normal))
			var _axis = _up.cross(_adjusted_normal)
			
			if !_axis.is_zero_approx():
				rotate(_axis.normalized(), _roll_angle * 7 * delta)
			else:
				rotate(global_basis.z, _roll_angle * 7 * delta)
		
		
		# Jumping
		if Input.is_action_just_pressed(\"Space\"):
			
			detach()
			_reorient = false
			velocity += lerp(-global_basis.z, _surface_normal, Settings.jump_angle).normalized() * jump_power * jump_stamina
			jump_stamina = 0
			
			global_position = camera.global_position
			move_and_collide(velocity.normalized())
	
	
	# Grappling
	if Input.is_action_just_pressed(\"Q\"):
		if !_anchored_shape or acos(_surface_normal.dot(global_basis.z)) > 1.25:
			var _space = get_world_3d().direct_space_state
			var _ray = PhysicsRayQueryParameters3D.create(camera.global_position, camera.global_position - global_basis.z * grapple_range)
			var _raycast = _space.intersect_ray(_ray)
			
			if !_raycast.is_empty():
				if _anchored_shape:
					global_position = camera.global_position
					move_and_collide(-global_basis.z)
				detach()
				_grapple_point = _raycast.position
	
	
	if _anchored_shape:
		camera.global_position = global_position + _surface_normal
		hitbox.global_position = global_position + _surface_normal * 0.35
		var _up : Vector3 = hitbox.global_basis.y
		var _angle : float = acos(_up.dot(_surface_normal))
		var _axis = _up.cross(_surface_normal)
		if !_axis.is_zero_approx():
			hitbox.global_rotate(_axis.normalized(), _angle)
	
	else:
		camera.global_position = global_position - velocity.normalized()
		hitbox.global_position = global_position - velocity.normalized() * 0.35
		var _up : Vector3 = -hitbox.global_basis.y
		var _angle : float = acos(_up.dot(velocity.normalized()))
		var _axis = _up.cross(velocity.normalized())
		if !_axis.is_zero_approx():
			hitbox.global_rotate(_axis.normalized(), _angle)
	
	
	# Delegate movement
	if _anchored_shape:
		_anchored_move(delta)
	else:
		_free_move(delta)



func _anchored_move(delta : float):
	
	# Calculating movement direction along the ground
	var _forward : Vector3 = (-global_basis.z + global_basis.z.dot(_surface_normal) * _surface_normal).normalized()
	var _side : Vector3 = (global_basis.x - global_basis.x.dot(_surface_normal) * _surface_normal).normalized()
	
	var _input := Input.get_vector(\"A\", \"D\", \"S\", \"W\")
	
	# Getting movement input
	match _movement_state:
		
		move_type.IDLE:
			
			if velocity.length() < walk_friction * delta:
				velocity = Vector3.ZERO
			else:
				velocity = velocity.limit_length(velocity.length() - walk_friction * delta)
		
		move_type.WALKING:
			
			velocity += ((_side * _input.x) + (_forward * _input.y)) * delta * walk_acceleration
			if velocity.length() > walk_max_speed + walk_friction * delta:
				velocity = velocity.limit_length(velocity.length() - walk_friction * delta)
			else:
				velocity = velocity.limit_length(walk_max_speed)
		
		move_type.SPRINTING:
			
			velocity += ((_side * _input.x) + (_forward * _input.y)) * delta * sprint_acceleration
			if velocity.length() > sprint_max_speed + walk_friction * delta:
				velocity = velocity.limit_length(velocity.length() - walk_friction * delta)
			else:
				velocity = velocity.limit_length(sprint_max_speed)
		
		move_type.SLIDING:
			
			velocity += _forward * _forward.dot(Gamemanager.get_gravity_vector()) + _side * _side.dot(Gamemanager.get_gravity_vector())
			if velocity.length() < slide_friction * delta:
				velocity = Vector3.ZERO
			else:
				velocity = velocity.limit_length(velocity.length() - slide_friction * delta)
	
	
	if velocity.is_zero_approx():
		return
	
	
	# Applying movement
	var _time = delta
	var _collision = move_and_collide(velocity * _time)
	var _loops = 0
	
	while _collision:
		
		var _shape = _collision.get_collider_shape()
		var _normal = _collision.get_normal()
		
		_time -= delta * (_collision.get_travel().length() / velocity.length())
		
		if _shape == _anchored_shape and acos(_surface_normal.dot(_normal)) <= 1.5:
			
			_surface_normal = _normal
			_forward = (-global_basis.z + global_basis.z.dot(_surface_normal) * _surface_normal).normalized()
			_side = (global_basis.x - global_basis.x.dot(_surface_normal) * _surface_normal).normalized()
			velocity = _forward * _forward.dot(velocity) + _side * _side.dot(velocity)
		
		
		else:
			velocity = velocity - velocity.dot(_normal) * _normal
		
		
		if _loops > 2:
			global_translate(_surface_normal)
		if _loops > 4:
			break
		
		_loops += 1
		_collision = move_and_collide(velocity * _time)
	
	
	# Checking we're still on the ground
	_collision = move_and_collide(_surface_normal * -100 * delta)
	
	if _collision and _collision.get_collider_shape() == _anchored_shape:
		_anchor_point_l = _anchored_shape.to_local(self.global_position)
		_surface_normal = _collision.get_normal()
	else:
		detach()



func _free_move(delta : float):
	
	# Apply gravity, if any
	velocity += Gamemanager.get_gravity_vector() * delta
	
	
	# Grapple
	if _grapple_point != Vector3.ZERO:
		velocity = (velocity + global_position.direction_to(_grapple_point) * grapple_acceleration * delta).limit_length(grapple_max_speed)
	
	
	# Try to move to our new position
	var _collision = move_and_collide(velocity * delta)
	
	while _collision:
		
		var _shape = _collision.get_collider_shape()
		var _normal = _collision.get_normal()
		
		if \"get_is_grabbable\" in _shape and _shape.get_is_grabbable():
			attach(_shape, _normal)
			_anchored_move(_collision.get_remainder().length()/velocity.length())
			return
		
		else:
			_grapple_point = Vector3.ZERO
		
		if _collision.get_travel().length_squared() < 0.1:
			global_translate(_normal)
		
		#var _body = _shape.get_parent()
		#if \"centrifuge_angular_velocity\" in _body:
		#	velocity = lerp(velocity, (_body.global_position - global_position).cross(_body.centrifuge_angular_velocity), 0.5)
		
		_collision = move_and_collide(_collision.get_remainder().bounce(_normal) * 0.3)
		velocity = velocity.bounce(_normal) * 0.3
#endregion



func attach(_shape : CollisionShape3D, _normal : Vector3):
	
	global_position = camera.global_position
	move_and_collide(-_normal)
	camera.global_position = global_position + _normal
	
	_anchored_shape = _shape
	_anchor_point_l = _anchored_shape.to_local(global_position)
	_surface_normal = _normal
	
	if _grapple_point != Vector3.ZERO:
		_grapple_point = Vector3.ZERO
		velocity = Vector3.ZERO
	else:
		velocity = velocity - velocity.dot(_surface_normal) * _surface_normal
		
		var _body = _shape.get_parent()
		if \"centrifuge_angular_velocity\" in _body:
			velocity -= (_body.global_position - global_position).cross(_body.centrifuge_angular_velocity)
		
		if velocity.length() > sprint_max_speed:
			velocity *= 0.9
		elif velocity.length() > walk_max_speed:
			velocity *= 0.95



func detach():
	if !_anchored_shape:
		return
	
	var _forward : Vector3 = (-global_basis.z + global_basis.z.dot(_surface_normal) * _surface_normal).normalized()
	var _side : Vector3 = (global_basis.x - global_basis.x.dot(_surface_normal) * _surface_normal).normalized()
	
	var _body = _anchored_shape.get_parent()
	
	if \"centrifuge_angular_velocity\" in _body:
		velocity += (_body.global_position - global_position).cross(_body.centrifuge_angular_velocity)
	
	_anchored_shape = null
	
	_movement_state = move_type.IDLE



func is_anchored() -> bool:
	if _anchored_shape:
		return true
	else:
		return false



func get_velocity() -> Vector3:
	if _anchored_shape:
		var _body = _anchored_shape.get_parent()
		if \"centrifuge_angular_velocity\" in _body:
			return velocity + (_body.global_position - global_position).cross(_body.centrifuge_angular_velocity)
	return velocity



func _on_synchronization():
	update_time = Time.get_ticks_msec()



func damage(dmg, tearing, headshot):
	health = max(health - dmg, 0)
	breach = max(breach, tearing)
	set_health.rpc_id(int(str(name)), health, breach, headshot)



@rpc(\"any_peer\", \"call_remote\", \"reliable\")
func set_health(new_health : float, new_breach : float, headshot : bool):
	if new_health < health:
		print(\"damaged\")
		damaged.emit()
		if headshot:
			Audiomanager.play(\"res://assets/bullet_headshot.mp3\")
		elif new_breach > breach:
			Audiomanager.play(\"res://assets/bullet_breach.mp3\")
		else:
			Audiomanager.play(\"res://assets/bullet_hit.mp3\")
	
	health = new_health
	breach = new_breach
	
	hud.set_health(health)



@rpc(\"any_peer\", \"call_local\", \"reliable\")
func die():
	if is_multiplayer_authority():
		UiManager.set_ui(0)
	
	death.emit(int(str(name)))
	queue_free()
"

[sub_resource type="SphereShape3D" id="SphereShape3D_ufnhc"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_jomgw"]
radius = 0.25
height = 1.2

[sub_resource type="CapsuleMesh" id="CapsuleMesh_r400h"]
radius = 0.25
height = 1.2

[sub_resource type="SphereShape3D" id="SphereShape3D_p56ql"]
radius = 0.2

[sub_resource type="SphereMesh" id="SphereMesh_lmg7g"]
radius = 0.2
height = 0.4

[sub_resource type="SceneReplicationConfig" id="SceneReplicationConfig_0uupb"]
properties/0/path = NodePath(".:position")
properties/0/spawn = true
properties/0/replication_mode = 1
properties/1/path = NodePath(".:rotation")
properties/1/spawn = true
properties/1/replication_mode = 1
properties/2/path = NodePath("Hitbox:position")
properties/2/spawn = true
properties/2/replication_mode = 1
properties/3/path = NodePath("Hitbox:rotation")
properties/3/spawn = true
properties/3/replication_mode = 1
properties/4/path = NodePath("Camera3D:position")
properties/4/spawn = true
properties/4/replication_mode = 1
properties/5/path = NodePath("Camera3D:rotation")
properties/5/spawn = true
properties/5/replication_mode = 1
properties/6/path = NodePath(".:team")
properties/6/spawn = true
properties/6/replication_mode = 1

[node name="Player" type="RigidBody3D" groups=["Players"]]
top_level = true
collision_layer = 0
can_sleep = false
freeze = true
script = SubResource("GDScript_qj47s")

[node name="PlayerBody" type="CollisionShape3D" parent="."]
shape = SubResource("SphereShape3D_ufnhc")

[node name="Camera3D" type="Camera3D" parent="."]

[node name="SpotLight3D" type="SpotLight3D" parent="Camera3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -0.0406958)
light_color = Color(0.858824, 0.882353, 0.968627, 1)
light_energy = 0.025
light_volumetric_fog_energy = 0.0
spot_range = 10.0
spot_angle = 70.0
spot_angle_attenuation = 1.41421

[node name="Hitbox" type="RigidBody3D" parent="."]
collision_layer = 2
collision_mask = 0
can_sleep = false
freeze = true

[node name="Hitbox" parent="Hitbox" node_paths=PackedStringArray("player") instance=ExtResource("1_2yv3f")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.150896, 0)
shape = SubResource("CapsuleShape3D_jomgw")
player = NodePath("../..")
damage = 1.0

[node name="MeshInstance3D" type="MeshInstance3D" parent="Hitbox"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.150347, 0)
mesh = SubResource("CapsuleMesh_r400h")
skeleton = NodePath("../../PlayerBody")

[node name="Hitbox2" parent="Hitbox" node_paths=PackedStringArray("player") instance=ExtResource("1_2yv3f")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.6533, 0)
shape = SubResource("SphereShape3D_p56ql")
player = NodePath("../..")
damage = 2.0

[node name="MeshInstance3D2" type="MeshInstance3D" parent="Hitbox"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.653123, 0)
mesh = SubResource("SphereMesh_lmg7g")
skeleton = NodePath("../../PlayerBody")

[node name="MultiplayerSpawner" type="MultiplayerSpawner" parent="."]
_spawnable_scenes = PackedStringArray("res://weapons/ak12/ak12.tscn", "res://weapons/vector/vector.tscn", "res://weapons/glock/glock.tscn", "res://weapons/grenades/he_display.tscn", "res://weapons/healing/sealant.tscn", "res://weapons/healing/healthkit.tscn")
spawn_path = NodePath("../Camera3D")

[node name="MultiplayerSynchronizer" type="MultiplayerSynchronizer" parent="."]
replication_config = SubResource("SceneReplicationConfig_0uupb")

[node name="AudioStreamPlayer3D" type="AudioStreamPlayer3D" parent="."]

[connection signal="synchronized" from="MultiplayerSynchronizer" to="." method="_on_synchronization"]
